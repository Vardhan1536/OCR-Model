# -*- coding: utf-8 -*-
"""hackathon1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pcDpI4hVTCxzrcUllBbwUYx3q9jF1ocF
"""

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All"
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session



from paddleocr import PaddleOCR
import os
from PIL import Image,ImageDraw,ImageFont
import json
from uuid import uuid4
import numpy as np

ocr = PaddleOCR(use_angle_cls=True,
                det_db_box_thresh=0.2,  # Lower the threshold for more text detection
                det_db_unclip_ratio=2.5,
                lang='en',
                rec = False,
                det_limit_side_len=1536
               )  # Increase unclip ratio to capture more text area


import cv2
import matplotlib.pyplot as plt

# Import necessary libraries



# Initialize PaddleOCR with the desired language (e.g., 'en' for English)
 # need to run only once to download model weights

# Load an image




# Define the OCR function
def perform_ocr(image_path, json_output_path='ocr_output.json', output_image_path='ocr_output_with_boxes.png'):
    Image.MAX_IMAGE_PIXELS = None
    img = Image.open(image_path)
    target_resolution = (3840, 2160)
    resized_img = img.resize(target_resolution, Image.Resampling.LANCZOS)
    resized_img.save(output_image_path)
    
    # Read the image
    img = cv2.imread(output_image_path)
    
    # Perform OCR on the image
    results = ocr.ocr(img, cls=True)
    
    # Display the recognized text
    print("Detected Text:")
    for line in results:
        for word_info in line:
            print(word_info[1][0])  # Print the detected text
    
    # Prepare output for JSON
    output = []
    for line in results:
        for word_info in line:
            text = word_info[1][0]  # Detected text
            confidence = word_info[1][1]  # Confidence score
            box = word_info[0]  # Bounding box coordinates
            output.append({
                "text": text,
                "confidence": confidence,
                "bounding_box": box
            })
    
    # Save results to a JSON file
    with open(json_output_path, 'w') as json_file:
        json.dump(output, json_file, indent=4)
    print(f"OCR results saved to '{json_output_path}'")
    
    # Draw bounding boxes on the image
    for line in results:
        for word_info in line:
            box = np.array(word_info[0]).astype(int)
            cv2.polylines(img, [box], isClosed=True, color=(0, 255, 0), thickness=2)
    
    # Display the image with bounding boxes
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

    # Save the image with bounding boxes
    cv2.imwrite(output_image_path, img)
    print(f"Image with bounding boxes saved as '{output_image_path}'")
    return output_image_path,output
# Example usage:
# image_path = "your_image_path_here.jpg"  # Replace with your image path
# perform_ocr(image_path)
